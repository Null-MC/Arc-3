import aperture;
import lib.common;
import lib.light.floodfill;
import hsv;


extern static const bool PointLight_Enabled;

static const float LpvFalloff = 0.998;
static const int3 flattenShared = int3(1, 10, 100);
static const float LpvBlockRange = 0.2;

groupshared uint sharedBlockMap[10*10*10];
groupshared uint sharedBlockMetaMap[10*10*10];
groupshared float3 floodfillBuffer[10*10*10];

[[vk::image_format("rgba16f")]]
RWTexture3D<float4> imgFloodFill_write;

Sampler3D texFloodFill_read;


int getSharedCoord(int3 pos) {
	return sumOf(pos * flattenShared);
}

int3 GetVoxelFrameOffset() {
    // float3 posNow = GetVoxelCenter(ap.camera.position, ap.camera.viewInv[2].xyz);
    // float3 posPrev = GetVoxelCenter(ap.temporal.position, ap.temporal.viewInv[2].xyz);
    float3 posNow = GetVoxelCenter(ap.camera.position);
    float3 posPrev = GetVoxelCenter(ap.temporal.position);

    float3 posLast = fract(posNow) + (ap.temporal.position - posPrev) - (ap.camera.position - posNow);
    return int3(floor(posLast));
}

float3 floodfill_sample_prev(in int3 texCoord) {
	if (!FloodFill_InBounds(texCoord)) return 0.0;

	// bool altFrame = ap.timing.frameCounter % 2 == 1;

	// float3 lpvSample = altFrame
	// 	? imageLoad(imgFloodFill, texCoord).rgb
	// 	: imageLoad(imgFloodFill_alt, texCoord).rgb;
	float3 lpvSample = texFloodFill_read[texCoord].rgb;

	float3 hsv = RgbToHsv(lpvSample);
	hsv.z = exp2(hsv.z * LpvBlockRange) - 1.0;
	lpvSample = HsvToRgb(hsv);

	return lpvSample;
}

void populateShared(ComputeInput input) {
	uint i1 = uint(input.groupIndex) * 2u;
	if (i1 >= 1000u) return;

	uint i2 = i1 + 1u;
	int3 workGroupOffset = int3(input.groupPos * WorkgroupSize()) - 1;

	int3 pos1 = workGroupOffset + int3(i1 / flattenShared) % 10;
	int3 pos2 = workGroupOffset + int3(i2 / flattenShared) % 10;

	int3 voxelFrameOffset = GetVoxelFrameOffset();
	floodfillBuffer[i1] = floodfill_sample_prev(pos1 - voxelFrameOffset);
	floodfillBuffer[i2] = floodfill_sample_prev(pos2 - voxelFrameOffset);

	uint blockId1 = 0u;
	uint blockId2 = 0u;
	uint blockMeta1 = 0u;
	uint blockMeta2 = 0u;

	if (voxel_isInBounds(pos1)) {
		blockId1 = ap.voxel[pos1].blockId;

		if (blockId1 > 0u)
			blockMeta1 = ap.blocks[blockId1].metadata;
	}

	if (voxel_isInBounds(pos2)) {
		blockId2 = ap.voxel[pos2].blockId;

		if (blockId2 > 0u)
			blockMeta2 = ap.blocks[blockId2].metadata;
	}

	sharedBlockMap[i1] = blockId1;
	sharedBlockMap[i2] = blockId2;

	sharedBlockMetaMap[i1] = blockMeta1;
	sharedBlockMetaMap[i2] = blockMeta2;
}

float3 sampleFloodfillShared(int3 pos, uint mask_index) {
	int shared_index = getSharedCoord(pos);
//	uint blockMeta = sharedBlockMetaMap[shared_index];
//	uint wMask = bitfieldExtract(blockMeta, int(mask_index), 1);
	return floodfillBuffer[shared_index];// * wMask;
}

float3 mixNeighbours(const in int3 fragCoord, const in uint mask) {
	uint3 m1 = 1u - (uint3(mask) >> uint3(BLOCK_FACE_WEST, BLOCK_FACE_UP, BLOCK_FACE_NORTH)) & 1u;
	uint3 m2 = 1u - (uint3(mask) >> uint3(BLOCK_FACE_EAST, BLOCK_FACE_DOWN, BLOCK_FACE_SOUTH)) & 1u;

	float3 nX1 = sampleFloodfillShared(fragCoord + int3(-1,  0,  0), BLOCK_FACE_EAST) * m1.x;
	float3 nX2 = sampleFloodfillShared(fragCoord + int3( 1,  0,  0), BLOCK_FACE_WEST) * m2.x;
	float3 nY1 = sampleFloodfillShared(fragCoord + int3( 0, -1,  0), BLOCK_FACE_DOWN) * m1.y;
	float3 nY2 = sampleFloodfillShared(fragCoord + int3( 0,  1,  0), BLOCK_FACE_UP) * m2.y;
	float3 nZ1 = sampleFloodfillShared(fragCoord + int3( 0,  0, -1), BLOCK_FACE_SOUTH) * m1.z;
	float3 nZ2 = sampleFloodfillShared(fragCoord + int3( 0,  0,  1), BLOCK_FACE_NORTH) * m2.z;

	const float avgFalloff = (1.0/6.0) * LpvFalloff;
	return (nX1 + nX2 + nY1 + nY2 + nZ1 + nZ2) * avgFalloff;
}


struct ComputeInput {
    uint groupIndex : SV_GroupIndex;
    uint3 groupPos : SV_GroupID;
    uint3 localPos : SV_GroupThreadID;
    uint3 globalPos : SV_DispatchThreadID;
};

[[shader("compute")]]
[numthreads(8, 8, 8)]
void floodfill(ComputeInput input) {
	uint3 chunkPos = input.groupPos * WorkgroupSize();
	if (any(chunkPos >= FloodFill_BufferSize)) return;

	populateShared(input);
	GroupMemoryBarrierWithGroupSync();

	int3 cellIndex = int3(input.globalPos);
	if (any(cellIndex >= FloodFill_BufferSize)) return;

	//bool altFrame = ap.timing.frameCounter % 2 == 1;

    //vec3 viewDir = ap.camera.viewInv[2].xyz;
    //vec3 voxelCenter = GetVoxelCenter(ap.camera.pos, viewDir);
    float3 localPos = FloodFill_GetLocalPosition(cellIndex + 0.5);

	int3 localCellIndex = int3(input.localPos);
	int sharedCoord = getSharedCoord(localCellIndex + 1);
	uint blockId = sharedBlockMap[sharedCoord];

	bool isFullBlock = false;
	float3 blockTint = 1.0;
	float3 lightColor = 0.0;
	uint lightRange = 0;

	if (blockId > 0u) {
		var blockData = ap.blocks[blockId];
		isFullBlock = blockData.isFullBlock;

		//if (blockData.hasTag(TAG_STAIRS)) isFullBlock = true;

		lightColor = blockData.lightColor.rgb;
		lightColor = RgbToLinear(lightColor);

		lightRange = blockData.emission;

		if (lightRange == 0) {
			// TODO: is this reliable?
			blockTint = lightColor;

//				uint meta = sharedBlockMetaMap[sharedCoord];
//				uint blocking = bitfieldExtract(meta, 10, 4);
//				blockTint *= 1.0 - blocking/16.0;
		}

		if (PointLight_Enabled) {
			//if (!iris_hasTag(blockId, TAG_NON_POINT_LIGHT)) lightRange = 0;
			if (lightRange >= 5 && !blockData.isFluid) lightRange = 0;
			// TODO: also enable if out of point volume?
		}
	}

	float3 accumLight = 0.0;

	if (!isFullBlock) {
		uint faceMask = 0u;
		if (blockId > 0u)
			faceMask = sharedBlockMetaMap[sharedCoord];

		accumLight = mixNeighbours(localCellIndex + 1, faceMask) * blockTint;
	}

	if (lightRange > 0) {
		float3 hsv = RgbToHsv(lightColor);
		hsv.z = exp2((1.0/15.0) * lightRange) - 1.0;
		accumLight += HsvToRgb(hsv);
	}

	float3 hsv = RgbToHsv(accumLight);
	hsv.z = log2(hsv.z + 1.0) / LpvBlockRange;
	accumLight = HsvToRgb(hsv);

	// if (altFrame) imageStore(imgFloodFill_alt, cellIndex, vec4(accumLight, 1.0));
	// else imageStore(imgFloodFill, cellIndex, vec4(accumLight, 1.0));
	imgFloodFill_write[cellIndex] = float4(accumLight, 1.0);
}
